<!DOCTYPE html>
<html>

<head>
    <title>Datastructures - Technical Documentation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
    <nav id="navbar">
      <!--   <div class="left-nav"> -->
            <div class="nav-header"><header>Data Structures</header>
            </div>
            <hr>
            <ul class="nav-list">
                <li><a href="#Big_O" class="nav-link">Big O</a></li>
                <li><a href="#Arrays" class="nav-link">Arrays</a></li>
                <li><a href="#Linked_List" class="nav-link">Linked List</a></li>
                <li><a href="#Stacks_&_Queues" class="nav-link">Stacks & Queues</a></li>
                <li><a href="#Hash_Table" class="nav-link">Hash Table</a></li>
                <li><a href="#Binary_Tree" class="nav-link">Binary Tree</a></li>
                <li><a href="#Binary_Heap" class="nav-link">Binary Heap</a></li>
                <li><a href="#Graph" class="nav-link">Graph</a></li>
            </ul>
       <!--  </div> -->
    </nav>
    <main id="main-doc">
        <div class="main-area">
            <section id="Big_O" class="main-section">
                <header>Big O</header>
                <article>
                <h3>What?</h3>
                <ul>
                    <li>A notation to express time and space complexity of algorithms</li>
                </ul>
                <h3>Why?</h3>
                <ul>
                    <li>Standardized measure to quantify algorithm efficiency</li>
                </ul>
                <h3>How?</h3>
<ul>
    <li>Linear Time: <em>O(n+n)=O(n)</em></li>
</ul>
<pre>
<code>
for(int i=0;i&lt;arr.length;i++){
    //operations - O(n)
}
for(int i=0;i&lt;arr.length;i++){
    //operations - O(n)
}
</code>
</pre>

<ul>
    <li>Quadratic Time: <em>O(n * n)=O(n^2)</em></li>
</ul>

<pre>
<code>
for (int i=0;i&lt;arr.length;i++) {
    for (int j=0;j&lt;arr.length;j++) {
        //operations - O(n * n)
    }
}
</code>
</pre>
                <ul>
                    <li>Looping through 2 data structures of varying size: <em>O(n+m)</em></li>
                </ul>
<pre>
<code>
while (counter < i)
i-- //O(n)

while (counter < j)
j-- //O(m)
</code>
</pre>
                <ul>
                    <li>Drop the constants in comparison to O(n): <em>O(n+n) = O(n)</em></li>
                </ul><pre>
                <code>
while (counter &lt; i) {
 counter-- // O(n)
 if(counter %2 == 0) // O(1)
}
</code></pre>
</article>
            </section>
            <section id="Arrays" class="main-section">
                <header>Arrays</header>
                <article>
                <h3>What?</h3>
                <ul>
                    <li>Index based <strong>fixed capacity</strong> data structure</li>
                </ul>
                <h3>Why?</h3>
                <ul>
                    <li>Fast random access</li>
                </ul>
                <h3>How?</h3>
                <ul>
                    <li>
                        <p>Primitive data structure<br />
                            | 0 | 1 | 2 | 3 | 4 |</p>
                    </li>
                </ul>
                <ul>
                    <li>
                        Insert at index 2:<br /></li></ul>
<pre>
<code>
if (size == capacity){
	create new array with double the capacity;
	copy contents of old array to new array;
	point old array to new array;
}

for(int j=2;j<=length;j++){

	<strong>Iteration - 1</strong>
	nextValue=array[j]; //nextValue=2
	array[j]=newValue; //array[2]=5
	newValue=nextValue; //newValue=2

	<strong>Iteration - 2</strong>
	nextValue=array[j]; //nextValue=3
	array[j]=newValue; //array[3]=2
	newValue=nextValue; //newValue=3

	<strong>Iteration - 3</strong>
	nextValue=array[j]; //nextValue=4
	array[j]=newValue; //array[4]=3
	newValue=nextValue; //newValue=4

	<strong>Iteration - 4</strong>
	nextValue=array[j]; //nextValue=0
	array[j]=newValue; //array[5]=4
	newValue=nextValue; //newValue=0

}

set value at 2;
set capacity = 2*initial_capacity;
set size = size+1;

</code>
</pre>
               <ul>                   
                    <li>
                        <p>Delete data at index 2:<br /> </li></p></li></ul>
<pre>
<code>
    for(int j=2;j&lt;length-1;j++){<br />
    array[j]=array[j+1];
</code>
</pre>
                
               
                <h3>Where?</h3>
                <ul>
                    <li>ArrayList is an API implemention on top of Arrays providing convenience methods for dynamic resizing and other operations.</li>
                </ul>
                <h3>Time complexity</h3>
                <ul>
                    <li>Get/Set - O(1)</li>
                    <li>Insert/Delete - O(n)</li>
                </ul>
                </article>
            </section>
            <section id="Linked_List" class="main-section">
                <header>Linked List</header>
                <article>
                <h3>What?</h3>
                <ul>
                    <li>List of linked nodes with unlimited capacity</li>
                </ul>
                <h3>Why?</h3>
                <ul>
                    <li>To maintain insertion order</li>
                    <li>Fast add/remove from tail/head respectively for Queue</li>
                    <li>Fast push/pop from top for stacks</li>
                </ul>
                <h3>How?</h3>
                <ul>
                    <li>Head -&gt; Node1 -&gt; Node2 -&gt; Tail -&gt; NULL</li>
                   <li>Add an element to queue<br /></li></ul>
                    <pre><code>
Tail.next = NewNode;<br />
NewNode.next = null;<br />
Tail = NewNode;
                    </code></pre>                        
                    <ul>
                    <li>                       
                    Remove an element from queue<br /></li></ul>
                    <pre><code> 
data = Head.data;<br />
Head = Head.next;<br />
return data;                        
                    </code></pre>
                    <ul>
                    <li>
                    Push an element to stack<br /></li></ul>
                    <pre><code>
NewNode.next = Head;<br />
Head = NewNode;                       
                    </code></pre>
                    <ul>
                    <li>
                    Pop an element from stack<br /></li></ul>
                    <pre><code>
data = Head.data;<br />
Head = Head.next;<br />
return data;
                    </code></pre>
                <h3>Where?</h3>
                <ul>
                    <li>Stacks and Queues</li>
                </ul>
                <h3>Time complexity</h3>
                <ul>
                    <li>Add/Remove from front/back - O(1)</li>
                    <li>Insert anywhere else/Search - O(n)</li>
                </ul>
            </article>
            </section>

            <section id="Stacks_&_Queues" class="main-section">
                <header>Stacks & Queues</header>
                <article>
                <h3><a id="What_SQ"></a>What?</h3>
                <ul>
                    <li>Stack - Push and Pop from top</li>
                    <li>Queue - Add to tail and remove from head</li>
                </ul>
                <h3><a id="Why_SQ"></a>Why?</h3>
                <ul>
                    <li>Used to implement LIFO &amp; FIFO respectively</li>
                </ul>
                <h3><a id="How_SQ"></a>How?</h3>
                <ul>
                    <li>
                        <p>Typically implemented using LinkedList</p>
                        <ul>
                            <li>
                                <p>Head -&gt; Node1 -&gt; Node2 -&gt; Tail -&gt; NULL</p>
                            </li>
                        </ul>
                    </li>
                </ul>
                        <ul>
                            <li>
                                Stack<br></li></ul>                               
<pre><code>
<strong>Pop</strong><br>
data = Head.data;<br>
Head = Head.next;<br>
return data;
</code></pre>

<pre><code>
<strong>Push</strong><br>
NewNode.next = Head;<br>
Head = NewNode;
</code></pre>

<ul><li>Queue<br></li></ul>
                                
<pre><code>
<strong>Add</strong><br>
Tail.next = NewNode;<br>
NewNode.next = null;<br>
Tail = NewNode;
</code></pre>

<pre><code>
<strong>Remove</strong><br>
data = Head.data;<br>
Head = Head.next;<br>
return data;
</code></pre>
                            </li>
                        </ul>
                    </li>
                </ul>
                <h3><a id="Stack_Queue_Time_complexity"></a>Time complexity:</h3>
                <ul>
                    <li>Add/Remove from front/back - O(1)</li>
                    <li>Insert anywhere else/Search - O(n)</li>
                </ul>
            </article>
            </section>
            <section id="Hash_Table" class="main-section">
<header>Hash Table</header>
<article>
<h3>What?</h3>
<ul>
<li>Data structure for constant time look ups</li>
<li>Analogous to dictionary lookup.</li>
<li>Key used for alphabet is a number derived from unique attributes of the value</li>
</ul>
<h3>Why?</h3>
<ul>
<li>Dictionary datastructure used for super fast lookups</li>
<li>Efficiency is proportional to the available space</li>
</ul>
<h3>How?</h3>
<ul>
<li>
<p>Implemented using Array of LinkedList</p>
</li>
<li>
<p>Derive a number (hashcode) using key attributes of the object to be stored (Hash function)</p>
</li>
<li>
<p>Use hashcode as array index</p>
</li>
<li>
<p>If the key is not unique i.e:  array index is not empty, then <strong>collision</strong> is said to have occured</p>
</li>
<li>
<p>In the event of key collision, start chaining the nodes</p>
</li>
<li>
<p>Typical hash function in Java</p>
</li>
</ul>
<pre><code>return 31 * (this.name.hashCode + this.id)</code></pre>
<ul>
<li>Moduls (%) operation is used to keep the derived key (array index) within the range</li>
</ul>
<pre><code>if capacity of array is 16, then<br>index = hashcode % 16<br><br>Example:<br>if hashcode = 32
then index = 32 % 16 = 2</code></pre>
<h3>Time complexity:</h3>
<ul>
<li>Get/Set/Delete
<ul>
<li>Worst-case scenario: Key collision - O(n)</li>
<li>Best-case scenario - O(1)</li>
</ul>
</li>
</ul></article>
            </section>            
            <section id="Binary_Tree" class="main-section">
                <header>Binary Tree</header>
                <article>
<h3>What?</h3>
<ul>
<li>Ordered and recursive tree data structure</li>
<li>Ordered so that each time we traverse down, we can eliminate half of the tree leading to logarthimic search time</li>
<li>Recursive because binary tree is compose of multiple binary trees</li>
</ul>
<h3>Why?</h3>
<ul>
<li>Faster key based range and general lookup</li>
</ul>
<h3>How?</h3>
<ul>
<li>left &lt; root &gt; right</li>
<li>Terms
<ul>
<li>root - top node</li>
<li>leaf - nodes without children</li>
<li>parent - nodes with children</li>
</ul>
</li>
<li>2 types of searches
<ul>
<li>Breadth first search</li>
<li>Depth first search</li>
</ul>
</li>
<li>3 types of traversals
<ul>
<li>Full - All nodes of level h-1 has 2 child nodes</li>
<li>Complete - Level 1 to h-1 is complete, h is completed from left to right</li>
<li>Balanced - Difference between the height of left subtree and right subtree should not be more than 1</li>
</ul>
</li>
</ul>
<h3>Time Complexity</h3>
<ul>
<li>Search - O(log n)</li>
<li>Insert -  O(log n)</li>
<li>Delete - O(log n)</li>
</ul>
                </article>
            </section>
            <section id="Binary_Heap" class="main-section">
                <header>Binary Heap</header>
                <article>TODO</article>
            </section>
            <section id="Graph" class="main-section">
                <header>Graph</header>
                <article>TODO</article>
            </section>     
        </div>
    </main>
</body>
</html>
<!DOCTYPE html>
<html>

<head>
    <title>Datastructures - Technical Documentation</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+SC" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="style.css">
    <script type="text/javascript" src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</head>

<body>
    <nav id="navbar">
        <div class="left-nav">
            <div class="nav-header"><h1>Data Structures</h1>
            </div>
            <hr>
            <ul class="nav-list">
                <li><a href="#BigO" class="nav-link">Big O</a></li>
                <li><a href="#Arrays" class="nav-link">Arrays</a></li>
                <li><a href="#LinkedList" class="nav-link">Linked List</a></li>
                <li><a href="#Stacks__Queues" class="nav-link">Stacks and Queues</a></li>
                <li><a href="#HashTable" class="nav-link">Hash Table</a></li>
                <li><a href="#BinaryTree" class="nav-link">Binary Tree</a></li>
                <li><a href="#BinaryHeap" class="nav-link">Binary Heap</a></li>
            </ul>
        </div>
    </nav>
    <main id="main-doc">
        <div class="main-area">
            <section id="BigO" class="main-section">
                <h2>Big O</h2>
                <h3>What?</h3>
                <ul>
                    <li>A notation to express time and space complexity of algorithms</li>
                </ul>
                <h3>Why?</h3>
                <ul>
                    <li>Standardized measure to quantify algorithm efficiency</li>
                </ul>
                <h3>How?</h3>
<ul>
    <li>Linear Time: <em>O(n+n)=O(n)</em></li>
</ul>
<pre>
<code>
for(int i=0;i&lt;arr.length;i++){
    //operations - O(n)				
}
for(int i=0;i&lt;arr.length;i++){
    //operations - O(n)				
}
</code>
</pre>

<ul>
    <li>Quadratic Time: <em>O(n * n)=O(n^2)</em></li>
</ul>

<pre>
<code>
for (int i=0;i&lt;arr.length;i++) {            	    
    for (int j=0;j&lt;arr.length;j++) {
        //operations - O(n * n)
    }				
}
</code>
</pre>
                <ul>
                    <li>Looping through 2 data structures of varying size: <em>O(n+m)</em></li>
                </ul>
<pre>
<code>
while (counter < i)
i-- //O(n)
						
while (counter < j)
j-- //O(m)
</code>
</pre>
                <ul>
                    <li>Drop the constants in comparison to O(n): <em>O(n+n) = O(n)</em></li>
                </ul><pre>
                <code>
while (counter &lt; i) {
 counter-- // O(n)
 if(counter %2 == 0) // O(1)
}
</code></pre>
            </section>
            <section id="Arrays" class="main-section">
                <h2>Arrays</h2>
                <h3>What?</h3>
                <ul>
                    <li>Index based <strong>fixed capacity</strong> data structure</li>
                </ul>
                <h3>Why?</h3>
                <ul>
                    <li>Fast random access</li>
                </ul>
                <h3>How?</h3>
                <ul>
                    <li>
                        <p>Primitive data structure<br />
                            | 0 | 1 | 2 | 3 | 4 |</p>
                    </li>
                </ul>
                <ul>
                    <li>
                        Insert at index 2:<br /></li></ul>
<pre>
<code>
if (size == capacity){
	create new array with double the capacity;
	copy contents of old array to new array;
	point old array to new array;
}

for(int j=2;j<=length;j++){

	<strong>Iteration - 1</strong>
	nextValue=array[j]; //nextValue=2
	array[j]=newValue; //array[2]=5
	newValue=nextValue; //newValue=2

	<strong>Iteration - 2</strong>
	nextValue=array[j]; //nextValue=3
	array[j]=newValue; //array[3]=2
	newValue=nextValue; //newValue=3

	<strong>Iteration - 3</strong>
	nextValue=array[j]; //nextValue=4
	array[j]=newValue; //array[4]=3
	newValue=nextValue; //newValue=4

	<strong>Iteration - 4</strong>
	nextValue=array[j]; //nextValue=0
	array[j]=newValue; //array[5]=4
	newValue=nextValue; //newValue=0

}

set value at 2;
set capacity = 2*initial_capacity;
set size = size+1;

</code>
</pre>
               <ul>                   
                    <li>
                        <p>Delete data at index 2:<br /> </li></p></li></ul>
<pre>
<code>
    for(int j=2;j&lt;length-1;j++){<br />
    array[j]=array[j+1];
</code>
</pre>
                
               
                <h3>Where?</h3>
                <ul>
                    <li>ArrayList is an API implemention on top of Arrays providing convenience methods for dynamic resizing and other operations.</li>
                </ul>
                <h3>Time complexity</h3>
                <ul>
                    <li>Get/Set - O(1)</li>
                    <li>Insert/Delete - O(n)</li>
                </ul>
            </section>
            <section id="LinkedList" class="main-section">
                <h2>Linked List</h2>
                <h3>What?</h3>
                <ul>
                    <li>List of linked nodes with unlimited capacity</li>
                </ul>
                <h3>Why?</h3>
                <ul>
                    <li>To maintain insertion order</li>
                    <li>Fast add/remove from tail/head respectively for Queue</li>
                    <li>Fast push/pop from top for stacks</li>
                </ul>
                <h3>How?</h3>
                <ul>
                    <li>Head -&gt; Node1 -&gt; Node2 -&gt; Tail -&gt; NULL</li>
                   <li>Add an element to queue<br /></li></ul>
                    <pre><code>
Tail.next = NewNode;<br />
NewNode.next = null;<br />
Tail = NewNode;
                    </code></pre>                        
                    <ul>
                    <li>                       
                    Remove an element from queue<br /></li></ul>
                    <pre><code> 
data = Head.data;<br />
Head = Head.next;<br />
return data;                        
                    </code></pre>
                    <ul>
                    <li>
                    Push an element to stack<br /></li></ul>
                    <pre><code>
NewNode.next = Head;<br />
Head = NewNode;                       
                    </code></pre>
                    <ul>
                    <li>
                    Pop an element from stack<br /></li></ul>
                    <pre><code>
data = Head.data;<br />
Head = Head.next;<br />
return data;
                    </code></pre>
                <h3>Where?</h3>
                <ul>
                    <li>Stacks and Queues</li>
                </ul>
                <h3>Time complexity</h3>
                <ul>
                    <li>Add/Remove from front/back - O(1)</li>
                    <li>Insert anywhere else/Search - O(n)</li>
                </ul>
            </section>
            <section id="Stacks__Queues" class="main-section">
                <h2>Stacks &amp; Queues</h2>
                <h3><a id="What_SQ"></a>What?</h3>
                <ul>
                    <li>Stack - Push and Pop from top</li>
                    <li>Queue - Add to tail and remove from head</li>
                </ul>
                <h3><a id="Why_SQ"></a>Why?</h3>
                <ul>
                    <li>Used to implement LIFO &amp; FIFO respectively</li>
                </ul>
                <h3><a id="How_SQ"></a>How?</h3>
                <ul>
                    <li>
                        <p>Typically implemented using LinkedList</p>
                        <ul>
                            <li>
                                <p>Head -&gt; Node1 -&gt; Node2 -&gt; Tail -&gt; NULL</p>
                            </li>
                            <li>
                                <h3><a id="Stack"></a>Stack:</h3>
                                <p><em>Pop</em><br>
                                    <pre><code>
data = Head.data;<br>
Head = Head.next;<br>
return data;<br>
                                    </code></pre>
                                    <em>Push</em><br>
                                    <pre><code>                                    
NewNode.next = Head;<br>
Head = NewNode;</p>
                                    </code></pre>
                            </li>
                            <li>
                                <h3><a id="Queue"></a>Queue:</h3>
                                <p><em>Add</em><br>
                                    <pre>
                                    <code>
Tail.next = NewNode;<br>
NewNode.next = null;<br>
Tail = NewNode;
                                    </code></pre><br>
                                    <em>Remove</em><br>
                                    <pre>
                                    <code>
data = Head.data;<br>
Head = Head.next;<br>
return data;
                                </code></pre></p>
                            </li>
                        </ul>
                    </li>
                </ul>
                <h3><a id="Stack_Queue_Time_complexity"></a>Time complexity:</h3>
                <ul>
                    <li>Add/Remove from front/back - O(1)</li>
                    <li>Insert anywhere else/Search - O(n)</li>
                </ul>
            </section>
            <section id="HashTable" class="main-section">
<h2>Hash Table</h2>
<h3>What?</h3>
<ul>
<li>Data structure for constant time look ups</li>
<li>Analogous to dictionary lookup.</li>
<li>Key used for alphabet is a number derived from unique attributes of the value</li>
</ul>
<h3>Why?</h3>
<ul>
<li>Dictionary datastructure used for super fast lookups</li>
<li>Efficiency is proportional to the available space</li>
</ul>
<h3>How?</h3>
<ul>
<li>
<p>Implemented using Array of LinkedList</p>
</li>
<li>
<p>Derive a number (hashcode) using key attributes of the object to be stored (Hash function)</p>
</li>
<li>
<p>Use hashcode as array index</p>
</li>
<li>
<p>If the key is not unique i.e:  array index is not empty, then <strong>collision</strong> is said to have occured</p>
</li>
<li>
<p>In the event of key collision, start chaining the nodes</p>
</li>
<li>
<p>Typical hash function in Java</p>
</li>
</ul>
<pre><code>return 31 * (this.name.hashCode + this.id)</code></pre>
<ul>
<li>Moduls (%) operation is used to keep the derived key (array index) within the range</li>
</ul>
<pre><code>if capacity of array is 16, then<br>index = hashcode % 16<br><br>Example:<br>if hashcode = 32
then index = 32 % 16 = 2</code></pre>
<h3>Time complexity:</h3>
<ul>
<li>Get/Set/Delete
<ul>
<li>Worst-case scenario: Key collision - O(n)</li>
<li>Best-case scenario - O(1)</li>
</ul>
</li>
</ul>
            </section>            
            <section id="BinaryTree" class="main-section">
                <h2>Binary Tree</h2>
                <p>TODO</p>
            </section>
            <section id="BinaryHeap" class="main-section">
                <h2>Binary Heap</h2>
                <p>TODO</p>
            </section>
            <section id="Graph" class="main-section">
                <h2>Graph</h2>
                <p>TODO</p>
            </section>     
        </div>
    </main>
</body>

</html>